/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PasteImageAsWebPPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  filenameFormat: "timestamp",
  fixedFilename: "image",
  timestampFormat: "YYYYMMDDHHmmss",
  imageFolder: "attachments",
  imageFolderLocation: "current-folder",
  // Default to current folder
  customFolderPath: "project/images",
  // Default custom path
  webpQuality: 0.85,
  maxImageSize: 16777216,
  // 4096 * 4096
  maxFileSizeMB: 10
};
var MAX_FILENAME_LENGTH = 255;
var MAX_DUPLICATE_ATTEMPTS = 1e3;
var UNSAFE_PATH_CHARS = /[<>:"|?*]/g;
var PATH_TRAVERSAL_PATTERN = /\.\.|[\\/]/g;
function removeControlCharacters(str) {
  return str.split("").filter((char) => {
    const code = char.charCodeAt(0);
    return !(code <= 31 || code >= 127 && code <= 159);
  }).join("");
}
var PasteImageAsWebPPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.workspace.on("editor-paste", this.handlePaste.bind(this))
    );
    this.addSettingTab(new PasteImageAsWebPSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Sanitizes a filename to remove dangerous characters
   */
  sanitizeFilename(filename) {
    let sanitized = removeControlCharacters(filename);
    sanitized = sanitized.replace(PATH_TRAVERSAL_PATTERN, "").replace(UNSAFE_PATH_CHARS, "_");
    sanitized = sanitized.trim().replace(/^\.+|\.+$/g, "");
    if (!sanitized) {
      sanitized = "image";
    }
    if (sanitized.length > MAX_FILENAME_LENGTH) {
      sanitized = sanitized.substring(0, MAX_FILENAME_LENGTH);
    }
    return sanitized;
  }
  /**
   * Validates and sanitizes a folder path
   */
  sanitizeFolderPath(path) {
    let sanitized = removeControlCharacters(path);
    sanitized = sanitized.replace(/\.\./g, "").replace(/^[/\\]+/, "").replace(/[/\\]+$/, "");
    sanitized = sanitized.replace(/\\/g, "/");
    sanitized = sanitized.replace(UNSAFE_PATH_CHARS, "_");
    if (!sanitized) {
      sanitized = "attachments";
    }
    if (sanitized.startsWith("/") || sanitized.match(/^[a-zA-Z]:/)) {
      sanitized = "attachments";
    }
    return sanitized;
  }
  /**
   * Validates image file size
   */
  validateFileSize(file) {
    const maxBytes = this.settings.maxFileSizeMB * 1024 * 1024;
    if (file.size > maxBytes) {
      throw new Error(`Image file size exceeds ${this.settings.maxFileSizeMB}MB limit`);
    }
  }
  /**
   * Validates image dimensions
   */
  validateImageDimensions(width, height) {
    const totalPixels = width * height;
    if (totalPixels > this.settings.maxImageSize) {
      throw new Error(`Image dimensions exceed maximum allowed size`);
    }
    if (width <= 0 || height <= 0 || width > 16384 || height > 16384) {
      throw new Error(`Invalid image dimensions`);
    }
  }
  async handlePaste(evt, editor, view) {
    var _a;
    const files = (_a = evt.clipboardData) == null ? void 0 : _a.files;
    if (!files || files.length === 0) {
      return;
    }
    const imageFiles = Array.from(files).filter(
      (file) => file.type.startsWith("image/")
    );
    if (imageFiles.length === 0) {
      return;
    }
    evt.preventDefault();
    for (const file of imageFiles) {
      await this.processImage(file, editor, view);
    }
  }
  async processImage(file, editor, view) {
    try {
      this.validateFileSize(file);
      const webpBlob = await this.convertToWebP(file);
      const filename = this.generateFilename();
      const filepath = await this.saveImage(webpBlob, filename, view);
      this.insertImageLink(editor, filepath);
      new import_obsidian.Notice(`Image saved as ${filename}`);
    } catch (error) {
      console.error("Error processing image:", error);
      const userMessage = this.getSafeErrorMessage(error);
      new import_obsidian.Notice(userMessage);
    }
  }
  /**
   * Returns a safe error message for user display
   */
  getSafeErrorMessage(error) {
    const errorMsg = error instanceof Error ? error.message : "";
    if (errorMsg.includes("exceeds") || errorMsg.includes("dimensions") || errorMsg.includes("Invalid")) {
      return errorMsg;
    }
    return "Failed to process image. Please check the image format and size.";
  }
  async convertToWebP(file) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      const reader = new FileReader();
      reader.onload = (e) => {
        var _a;
        img.onload = () => {
          try {
            this.validateImageDimensions(img.width, img.height);
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            if (!ctx) {
              reject(new Error("Failed to get canvas context"));
              return;
            }
            ctx.drawImage(img, 0, 0);
            canvas.toBlob(
              (blob) => {
                if (blob) {
                  resolve(blob);
                } else {
                  reject(new Error("Failed to convert to WebP"));
                }
              },
              "image/webp",
              this.settings.webpQuality
            );
          } catch (error) {
            reject(error instanceof Error ? error : new Error("Unknown error during conversion"));
          }
        };
        img.onerror = () => {
          reject(new Error("Failed to load image"));
        };
        img.src = (_a = e.target) == null ? void 0 : _a.result;
      };
      reader.onerror = () => {
        reject(new Error("Failed to read file"));
      };
      reader.readAsDataURL(file);
    });
  }
  generateFilename() {
    let baseFilename;
    if (this.settings.filenameFormat === "fixed") {
      baseFilename = this.sanitizeFilename(this.settings.fixedFilename);
    } else {
      const now = new Date();
      const format = this.sanitizeFilename(this.settings.timestampFormat);
      let filename = format.replace("YYYY", now.getFullYear().toString()).replace("MM", (now.getMonth() + 1).toString().padStart(2, "0")).replace("DD", now.getDate().toString().padStart(2, "0")).replace("HH", now.getHours().toString().padStart(2, "0")).replace("mm", now.getMinutes().toString().padStart(2, "0")).replace("ss", now.getSeconds().toString().padStart(2, "0"));
      baseFilename = this.sanitizeFilename(filename);
    }
    return `${baseFilename}.webp`;
  }
  async saveImage(blob, filename, view) {
    var _a;
    let folder;
    if (this.settings.imageFolderLocation === "current-folder") {
      const currentFile = view.file;
      let baseFolder;
      if (currentFile) {
        const currentFilePath = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
        baseFolder = currentFilePath;
      } else {
        baseFolder = "";
      }
      const folderName = this.sanitizeFolderPath(this.settings.imageFolder);
      folder = baseFolder ? `${baseFolder}/${folderName}` : folderName;
    } else if (this.settings.imageFolderLocation === "custom-path") {
      folder = this.sanitizeFolderPath(this.settings.customFolderPath);
    } else {
      const folderName = this.sanitizeFolderPath(this.settings.imageFolder);
      folder = folderName;
    }
    const folderExists = await this.app.vault.adapter.exists(folder);
    if (!folderExists) {
      await this.app.vault.createFolder(folder);
    }
    let filepath = `${folder}/${filename}`;
    let counter = 1;
    while (await this.app.vault.adapter.exists(filepath)) {
      if (counter >= MAX_DUPLICATE_ATTEMPTS) {
        throw new Error("Too many duplicate files. Please use a different filename format.");
      }
      const nameWithoutExt = filename.replace(".webp", "");
      filepath = `${folder}/${nameWithoutExt}-${counter}.webp`;
      counter++;
    }
    const arrayBuffer = await blob.arrayBuffer();
    await this.app.vault.createBinary(filepath, arrayBuffer);
    return filepath;
  }
  insertImageLink(editor, filepath) {
    const cursor = editor.getCursor();
    const imageMarkdown = `![[${filepath}]]`;
    editor.replaceRange(imageMarkdown, cursor);
    const newCursor = {
      line: cursor.line,
      ch: cursor.ch + imageMarkdown.length
    };
    editor.setCursor(newCursor);
  }
};
var PasteImageAsWebPSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Reset to defaults").setDesc("Reset all settings to their default values").addButton((button) => button.setButtonText("Reset to defaults").setCta().onClick(async () => {
      const confirmed = await this.confirmReset();
      if (confirmed) {
        await this.resetToDefaults();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Filename format").setDesc("Choose how to name the saved images").addDropdown((dropdown) => dropdown.addOption("fixed", "Fixed name").addOption("timestamp", "Timestamp").setValue(this.plugin.settings.filenameFormat).onChange(async (value) => {
      this.plugin.settings.filenameFormat = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.filenameFormat === "fixed") {
      new import_obsidian.Setting(containerEl).setName("Fixed filename").setDesc("Filename to use (without extension)").addText((text) => text.setPlaceholder("Image").setValue(this.plugin.settings.fixedFilename).onChange(async (value) => {
        this.plugin.settings.fixedFilename = value || "image";
        await this.plugin.saveSettings();
      }));
    }
    if (this.plugin.settings.filenameFormat === "timestamp") {
      new import_obsidian.Setting(containerEl).setName("Timestamp format").setDesc("Format: YYYY (year), MM (month), DD (day), HH (hour), mm (minute), ss (second)").addText((text) => text.setPlaceholder("YYYYMMDDHHmmss").setValue(this.plugin.settings.timestampFormat).onChange(async (value) => {
        this.plugin.settings.timestampFormat = value || "YYYYMMDDHHmmss";
        await this.plugin.saveSettings();
      }));
      const sampleFilename = this.generateSampleFilename();
      containerEl.createEl("div", {
        text: `Sample: ${sampleFilename}`,
        cls: "setting-item-description"
      });
    }
    new import_obsidian.Setting(containerEl).setName("Image folder location").setDesc("Where to create the image folder").addDropdown((dropdown) => dropdown.addOption("current-folder", "Same folder as current note").addOption("vault-root", "Vault root").addOption("custom-path", "Custom path").setValue(this.plugin.settings.imageFolderLocation).onChange(async (value) => {
      this.plugin.settings.imageFolderLocation = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.imageFolderLocation === "custom-path") {
      new import_obsidian.Setting(containerEl).setName("Custom folder path").setDesc('Full path to the folder (e.g., "project/images" or "resources/attachments")').addText((text) => text.setPlaceholder("Project/images").setValue(this.plugin.settings.customFolderPath).onChange(async (value) => {
        this.plugin.settings.customFolderPath = value || "project/images";
        await this.plugin.saveSettings();
      }));
      containerEl.createEl("div", {
        text: `Images will be saved to: ${this.plugin.settings.customFolderPath}/`,
        cls: "setting-item-description"
      });
    }
    if (this.plugin.settings.imageFolderLocation !== "custom-path") {
      const folderDescription = this.plugin.settings.imageFolderLocation === "current-folder" ? "Folder name (created in the same directory as the current note)" : "Folder path (relative to vault root)";
      new import_obsidian.Setting(containerEl).setName("Image folder name").setDesc(folderDescription).addText((text) => text.setPlaceholder("Attachments").setValue(this.plugin.settings.imageFolder).onChange(async (value) => {
        this.plugin.settings.imageFolder = value || "attachments";
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian.Setting(containerEl).setName("Image quality (WebP)").setDesc("Image quality (0.0 - 1.0, higher is better quality)").addSlider((slider) => slider.setLimits(0.1, 1, 0.05).setValue(this.plugin.settings.webpQuality).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.webpQuality = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Security").setHeading();
    new import_obsidian.Setting(containerEl).setName("Maximum image size").setDesc("Maximum total pixels (width \xD7 height). Default: 16777216 (4096\xD74096)").addText((text) => text.setPlaceholder("16777216").setValue(this.plugin.settings.maxImageSize.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.maxImageSize = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Maximum file size (MB)").setDesc("Maximum file size in megabytes. Default: 10 MB").addText((text) => text.setPlaceholder("10").setValue(this.plugin.settings.maxFileSizeMB.toString()).onChange(async (value) => {
      const numValue = parseFloat(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.maxFileSizeMB = numValue;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("div", {
      text: "Helps prevent malicious images from consuming excessive resources.",
      cls: "setting-item-description"
    });
  }
  generateSampleFilename() {
    const now = new Date();
    const format = this.plugin.settings.timestampFormat;
    let filename = format.replace("YYYY", now.getFullYear().toString()).replace("MM", (now.getMonth() + 1).toString().padStart(2, "0")).replace("DD", now.getDate().toString().padStart(2, "0")).replace("HH", now.getHours().toString().padStart(2, "0")).replace("mm", now.getMinutes().toString().padStart(2, "0")).replace("ss", now.getSeconds().toString().padStart(2, "0"));
    return `${filename}.webp`;
  }
  /**
   * Confirms with the user before resetting to defaults
   */
  async confirmReset() {
    return new Promise((resolve) => {
      const modal = new ConfirmResetModal(this.app, (confirmed) => {
        resolve(confirmed);
      });
      modal.open();
    });
  }
  /**
   * Resets all settings to default values
   */
  async resetToDefaults() {
    this.plugin.settings = Object.assign({}, DEFAULT_SETTINGS);
    await this.plugin.saveSettings();
    this.display();
    new import_obsidian.Notice("Settings reset to defaults");
  }
};
var ConfirmResetModal = class extends import_obsidian.Modal {
  constructor(app, onConfirm) {
    super(app);
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("p", {
      text: "Reset settings to defaults?"
    });
    contentEl.createEl("p", {
      text: "This will reset all settings to their default values. This action cannot be undone."
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.setCssProps({
      "display": "flex",
      "justify-content": "flex-end",
      "gap": "10px",
      "margin-top": "20px"
    });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
      this.onConfirm(false);
    });
    const resetButton = buttonContainer.createEl("button", {
      text: "Reset to defaults",
      cls: "mod-warning"
    });
    resetButton.addEventListener("click", () => {
      this.close();
      this.onConfirm(true);
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
